#### 列表：
##### 属性：
	1. length: 列表长度
	2. pos: 当前位置
	3. dataStore: 存放元素
##### 方法： 
	1. clear: 清除列表
	2. toString: 显示列表中元素
	3. getElement: 获取当前元素
	4. insert: 在某个元素后面插入新元素
	5. append: 在列表尾部追加元素
	6. remove: 删除某个元素
	7. front: 当前位置指向列表头
	8. end: 当前位置指向列表尾
	9. prev: 指向前一个位置
	10. next: 指向后一个位置
	11. hasNext: 后一位置是否有元素
	12. hasPrev: 前一位置是否有元素
	13. currPos: 返回当前位置
	14. moveTo: 移动到某一位置

#### 栈：
##### 属性：
	1. length: 栈中元素个数
	2. top: 栈顶位置
	3. dataStore: 存放栈元素
##### 方法：
	1. push: 入栈
	2. pop:	出栈
	3. peek: 查看栈顶元素
	4. clear: 清空栈

#### 树
	1. 实现树的创建，前中后序遍历
	2. 实现二叉排序树的创建，插入，删除

#### 排序算法：
	1. 冒泡排序
		总体描述：
			相邻元素进行比较，每次选取最大的元素，进行下一次比较，因此可以将最大的元素像冒泡一样，从某一位置，到达最顶端
		算法简单描述：
			假设：共有n个元素
			进行(n-1)次循环，第i(从1开始计数)次循环获得第i大的元素，放在数组第(n-i)(数组从0开始计数)位
			每次循环都从第一个元素开始，比较当前元素与其后一个元素的大小关系，如果后一个元素小于当前元素，则说明，当前元素较大，互换位置，即将（0～n-i区间最大的数放在n-i位），并将当前元素指向下一个位置，直到当前位置指向0，循环结束

	2. 选择排序
		总体描述：
			每次选择最小的元素，放在相应的位置上
		算法简单描述：
			假设：共有n个元素
			进行(n-1)次循环，第i(从1开始计数)次循环获得第i小的元素，放在数组第(i-1)(数组从0开始计数)位
			第i次循环，从数组第(i-1)位开始，将该位置元素与其后所有元素进行比较，获取较小元素索引，循环结束之后，将当前元素与最小索引位置元素位置互换，当前位置向前移动，进行下一轮循环，直到当前位置指向(n-1)

	3. 插入排序
		总体描述：
			将数组分为前后两部分，前一部分是已排序的元素集合，后一部分是未排序的元素集合。每次选中未排序的第一个数组，插入到已排序集合中的合适的位置
		算法简单描述：
			假设：共有n个元素
			从第2个元素开始，进行(n-1)次循环，第i次循环，将第i个元素插入到之前位置(1~i-1)中，将当前元素依次后面元素进行比较。比较元素起始值为当前元素前一位置元素，如果当前元素小于比较元素，比较元素向数组后面移动，当前元素继续与下一个元素进行比较，直到比较元素位置为0或者当前元素大于比较元素，将元素插入当前比较位置

	4. 希尔排序
		总体描述：
			希尔排序就是插入排序的优化，插入排序，每次将当前元素与之前的每一个元素进行比较，然后插入，希尔排序，相当于先按照一定步长，将数组进行分组，对每一组进行插入排序，这样就可以大幅度的调整数据的分布情况，最后执行一次快速排序进行微调
		算法简单描述：
			对于间隔数组中的每个元素gap，将数组元素根据gap分为gap组，对于每组进行插入排序

	5. 归并排序
		总体描述：
			自顶向下：先通过递归分解数组，再合并数组
		算法简单描述：
			分解数组：如果数组长度不为1，从中间将数组分为两部分，继续分解
			合并数组：将分解的数组融合，创建一个新数组，用于存放融合的数组元素。创建指针分别指向两个数组的首位，比较当前指针指向位置元素的大小，将较小的元素插入新数组中，指针向后移动，直到有一个数组元素全部移出。最后检查两个数组，将未移出的元素追加到新数组中，最后存放已排序的数组根据对应位置存入待排序数组中

	6. 快速排序
		总体描述：
			每次选取一个基准值，将数组中其他的元素和它进行比较，大于则移到数组右边，小于则移到左边。然后分类出来的数组继续进行上述操作。
		算法简单描述：
			选择数组第一位元素位基准值，创建两个新数组，分别存放小于基准值和大于基准值的元素。然后这两个新数组递归进行上述操作，直到数组为空。然后将左右数组和基准值进行拼接